\def\ltlabtbldate{2025-05-10}
\def\ltlabtblversion{0.85s}
\ProvidesExplPackage {tagpdf-table-headers} {\ltlabtbldate} {\ltlabtblversion}
  {Code related to the tagging of table headers}

%\cs_generate_variant:Nn \exp_args:NNe { cNe }
\cs_generate_variant:Nn \__tag_struct_prop_gput:nnn { Vne }
\cs_generate_variant:Nn \int_set:Nn { Ne }
\cs_generate_variant:Nn \str_range:nnn { een }

\clist_new:N \g__tbl_headerattribute_clist
%\int_new:N \g__tbl_row_int % already defined
\int_new:N \g__tbl_row_neg_int
\int_new:N \g__tbl_column_int
\int_new:N \g__tbl_column_neg_int
\int_new:N \l__tbl_next_column_int
\int_new:N \l__tbl_cell_id_int
\bool_new:N \l__tbl_found_header_bool

% these hooks aren't called?
%\hook_gput_code:nnn { cmd / after / __tbl_set_header_rows: } { latex-lab-testphase-table } { \__tbl_set_td_headers: }
%\AddToHook{ cmd / after / __tbl_set_header_rows: } { \__tbl_set_td_headers: }
% this doesn't work?
%\apptocmd{\__tbl_set_header_rows:}{\__tbl_set_td_headers:}{}{\fail}
% do it the old fashioned way
\tex_let:D \__tbl__old_set_header_rows: = \__tbl_set_header_rows:
\cs_set_protected:Npn \__tbl_set_header_rows:
  {
    \__tbl__old_set_header_rows:
    \__tbl_set_table_td_headers:
  }

\cs_new:Npn \__tbl_zero_pad:N #1
  {
    \str_range:een { \c__tbl_id_zero_prefix_str #1 } { - \c__tbl_id_size } { -1 }
  }

\cs_new:Npn \__tbl_set_table_td_headers:
  {
    \int_if_exist:NF \c__tbl_id_size
      {
        \str_set:Ne \l_tmpa_str { \tag_get:n { struct_id } }
        \int_const:Nn \c__tbl_id_size { \str_count:N \l_tmpa_str - 5 } % remove (ID. and )
		\str_const:Ne \c__tbl_id_zero_prefix_str { \prg_replicate:nn { \c__tbl_id_size } { 0 } }
      }
	\int_step_function:nN { \seq_count:N \g__tbl_struct_cells_seq } \__tbl_set_row_td_headers:n
  }

\cs_new:Npn \__tbl_set_row_td_headers:n #1
  {
    \int_gset:Nn \g__tbl_row_int { #1 }
    \int_gset:Nn \g__tbl_row_neg_int { #1 - 1 - \seq_count:N \g__tbl_struct_cells_seq }
    \exp_args:NNx \clist_set:Nn \l_tmpa_clist { \seq_item:Nn \g__tbl_struct_cells_seq { #1 } }
    \int_step_function:nN { \clist_count:N \l_tmpa_clist } \__tbl_set_td_headers:n
  }

% Set the headers for the column in index #1 (and the row in index #1 from \__tbl_set_row_td_headers:n)
\cs_new:Npn \__tbl_set_td_headers:n #1
  {
    \exp_args:NNx \clist_set:Nn \l_tmpa_clist { \seq_item:NV \g__tbl_struct_cells_seq \g__tbl_row_int }
    \int_gset:Nn \g__tbl_column_int { #1 }
    \__tbl_get_struct_cell:VVN \g__tbl_row_int \g__tbl_column_int \l__tbl_cell_id_int
    \int_compare:nNnT { 0 } < { \l__tbl_cell_id_int }
      { % otherwise, we're in a multicol, which was already handled
        \int_gset:Nn \g__tbl_column_neg_int { #1 - 1 - \clist_count:N \l_tmpa_clist }
        \clist_gclear:N \g__tbl_headerattribute_clist
        \__tbl_set_td_headers:
        \clist_if_empty:NF \g__tbl_headerattribute_clist
          { % if we found some headers
            \__tbl_get_struct_cell:VVN \g__tbl_row_int \g__tbl_column_int \l_tmpa_int
            \clist_remove_duplicates:N \g__tbl_headerattribute_clist
            \__tag_struct_prop_gput:Vne \l_tmpa_int { A } { <</O/Table/Headers~[~\clist_use:Nn \g__tbl_headerattribute_clist { ~ }~]~>> }
          }
      }
  }

% Set the headers for the particular TD.  Split off by itself so that we can recurse if necessary.
\cs_new:Npn \__tbl_set_td_headers:
  {
    \clist_if_in:NVF \l__tbl_header_rows_clist \g__tbl_row_int
      {
        \clist_if_in:NVF \l__tbl_header_rows_clist \g__tbl_row_neg_int
          {
            \__tbl_set_td_some_headers:Vnn \g__tbl_row_int        { -1 } { rows }
            \__tbl_set_td_some_headers:Vnn \g__tbl_row_neg_int    {  1 } { rows }
          }
      }
    \clist_if_in:NVF \l__tbl_header_columns_clist \g__tbl_column_int
      {
        \clist_if_in:NVF \l__tbl_header_columns_clist \g__tbl_column_neg_int
          {
            \__tbl_set_td_some_headers:Vnn \g__tbl_column_int     { -1 } { columns }
            \__tbl_set_td_some_headers:Vnn \g__tbl_column_neg_int {  1 } { columns }
   	      }
      }
    \int_set:Nn \l__tbl_next_column_int { \g__tbl_column_int + 1 }
    \__tbl_get_struct_cell:VVN \g__tbl_row_int \l__tbl_next_column_int \l__tbl_cell_id_int
    \int_compare:nT { \l__tbl_cell_id_int < 0 }
      { % The next column is a multicolumn continuing this one.  Also grab its headers.
        \int_gincr:N \g__tbl_column_int
        \__tbl_set_td_headers: % recurse
        \int_gdecr:N \g__tbl_column_int
      }
  }

% Starting from a positively/negatively indexed cell, we decr/incr that cell's row|column (given by #3).
% If we find a positively/negatively indexed header cell, record it and all subsequent header cells.
% We stop when we find a non-header cell.
% As a consequence, positively/negatively indexed headers can only be headers of cells that come after/before.
\cs_new:Npn \__tbl_set_td_some_headers:Vnn #1#2#3 % #1: start, #2: step, #3: rows|columns
  {
    \bool_set_false:N \l__tbl_found_header_bool
    \int_step_inline:nnnn { #1 } { #2 } { 0 }
      {
        \clist_if_in:cnTF { l__tbl_header_ #3 _clist } { ##1 }
          {
            \bool_set_true:N \l__tbl_found_header_bool
            \__tbl_get_struct_cell:VVnnN \g__tbl_row_int \g__tbl_column_int { #3 } { ##1 } \l__tbl_cell_id_int
            \int_set:Nn \l_tmpb_int { \int_abs:n { \l__tbl_cell_id_int } }
            \str_set:NV \l_tmpa_str \l_tmpb_int
            \str_set:Ne \l_tmpa_str { ( ID . \__tbl_zero_pad:N \l_tmpa_str ) }
            \clist_put_right:NV \g__tbl_headerattribute_clist \l_tmpa_str
          }
          { \bool_if:NT \l__tbl_found_header_bool { \prg_break: } }
      }
  }

\cs_new:Npn \__tbl_get_struct_cell:nnN #1#2#3 % #1: row, #2: column, #3: result
  { % If we look for an index that is too large, we get 0.
    \clist_set:Ne \l_tmpb_clist { \seq_item:Nn \g__tbl_struct_cells_seq { #1 } }
    \clist_if_exist:NTF \l_tmpb_clist
      {
        \int_set:Nn \l_tmpa_int { \clist_count:N \l_tmpb_clist }
        \int_compare:nNnTF { #2 } < { \l_tmpa_int+1 }
          {
            \int_set:Ne #3 { \clist_item:Nn \l_tmpb_clist { #2 } }
          }
          {
            \int_zero:N #3
          }
      }
      {
        \int_zero:N #3
      }
  }
\cs_generate_variant:Nn \__tbl_get_struct_cell:nnN { nVN, VnN, VVN }

\cs_new:Npn \__tbl_get_struct_cell:VVnnN #1#2#3#4#5
  % #1&2: starting row&column, #3: change rows|columns, #4: change to ..., #5: result
  {
    \str_if_eq:nnTF { #3 } { rows }
      {
        \__tbl_get_struct_cell:nVN {#4} #2 #5
      }
      {
        \__tbl_get_struct_cell:VnN #1 {#4} #5
      }
  }
