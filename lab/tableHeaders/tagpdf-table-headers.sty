\def\ltlabtbldate{2025-05-10}
\def\ltlabtblversion{0.85s}
\ProvidesExplPackage {tagpdf-table-headers} {\ltlabtbldate} {\ltlabtblversion}
  {Code related to the tagging of table headers}

%\cs_generate_variant:Nn \exp_args:NNe { cNe }
\cs_generate_variant:Nn \__tag_struct_prop_gput:nnn { Vne }
\cs_generate_variant:Nn \int_set:Nn { Ne }
\cs_generate_variant:Nn \str_range:nnn { een }

\clist_new:N \l__tbl_headerattribute_clist
\int_new:N \l__tbl_row_int
\int_new:N \l__tbl_row_neg_int
\int_new:N \l__tbl_column_int
\int_new:N \l__tbl_column_neg_int
\int_new:N \l__tbl_next_column_int
\int_new:N \l__tbl_cell_id_int
\bool_new:N \l__tbl_found_header_bool

% these hooks aren't called?
%\hook_gput_code:nnn { cmd / after / __tbl_set_header_rows: } { latex-lab-testphase-table } { \__tbl_set_td_headers: }
%\AddToHook{ cmd / after / __tbl_set_header_rows: } { \__tbl_set_td_headers: }
% this doesn't work?
%\apptocmd{\__tbl_set_header_rows:}{\__tbl_set_td_headers:}{}{\fail}
% do it the old fashioned way
\tex_let:D \__tbl__old_set_header_rows: = \__tbl_set_header_rows:
\cs_set_protected:Npn \__tbl_set_header_rows:
  {
    \__tbl__old_set_header_rows:
    \__tbl_set_table_td_headers:
  }

\AddToHook{begindocument}
  {
    \tag_if_active:T
      {
        \tagpdfsetup
          {
            role/new-attribute={TD}{/A},
            role/new-attribute={A}{/Headers},
            role/new-attribute={A}{/O},
%            role/new-attribute={A}{/O/Table},
%            role/new-attribute={TD}{/A~/Headers},
%            role/new-attribute={TD}{/A~/O}
          }
      }
  }

\cs_new:Npn \__tbl_zero_pad:N #1
  {
    \str_range:een { \c__tbl_id_zero_prefix_str #1 } { - \c__tbl_id_size } { -1 }
  }

\cs_new:Npn \__tbl_set_table_td_headers:
  {
    \int_if_exist:NF \c__tbl_id_size
      {
        \str_set:Ne \l_tmpa_str { \tag_get:n { struct_id } }
        \int_const:Nn \c__tbl_id_size { \str_count:N \l_tmpa_str - 5 } % remove (ID. and )
		\str_const:Ne \c__tbl_id_zero_prefix_str { \prg_replicate:nn { \c__tbl_id_size } { 0 } }
      }
	\int_step_function:nN { \seq_count:N \g__tbl_struct_cells_seq } \__tbl_set_row_td_headers:n
  }

\cs_new:Npn \__tbl_set_row_td_headers:n #1
  {
    \int_set:Nn \l__tbl_row_int { #1 }
    \int_set:Nn \l__tbl_row_neg_int { #1 - 1 - \seq_count:N \g__tbl_struct_cells_seq }
    \exp_args:NNx \clist_set:Nn \l_tmpa_clist { \seq_item:Nn \g__tbl_struct_cells_seq { #1 } }
    \int_step_function:nN { \clist_count:N \l_tmpa_clist } \__tbl_set_td_headers:n
  }

\cs_new:Npn \__tbl_set_td_headers:n #1
  {
    \exp_args:NNx \clist_set:Nn \l_tmpa_clist { \seq_item:NV \g__tbl_struct_cells_seq \l__tbl_row_int }
    \int_set:Nn \l__tbl_column_int { #1 }
    \int_set:Nn \l__tbl_column_neg_int { #1 - 1 - \clist_count:N \l_tmpa_clist }
    \clist_clear:N \l__tbl_headerattribute_clist
    \__tbl_set_td_headers:
    \clist_if_empty:NF \l__tbl_headerattribute_clist
      { % if we found some headers
        \__tbl_get_struct_cell:VVN \l__tbl_row_int \l__tbl_column_int \l_tmpa_int
        \clist_remove_duplicates:N \l__tbl_headerattribute_clist
        \__tag_struct_prop_gput:Vne \l_tmpa_int { A } { <</O/Table/Headers~[~\clist_use:Nn \l__tbl_headerattribute_clist { ~ }~]~>> }
      }
  }

\cs_new:Npn \__tbl_set_td_headers:
  {
%    \__tbl_get_struct_cell:VVN \l__tbl_row_int \l__tbl_column_int \l__tbl_cell_id_int
    \clist_if_in:NVF \l__tbl_header_rows_clist \l__tbl_row_int
      {
        \clist_if_in:NVF \l__tbl_header_rows_clist \l__tbl_row_neg_int
          {
            \clist_if_in:NVF \l__tbl_header_columns_clist \l__tbl_column_int
	          {
 	            \clist_if_in:NVF \l__tbl_header_columns_clist \l__tbl_column_neg_int
		          { % not a header cell.  find the appropriate headers
		            \__tbl_set_td_some_headers:Vnn \l__tbl_row_int        { -1 } { rows    }
		            \__tbl_set_td_some_headers:Vnn \l__tbl_row_neg_int    {  1 } { rows    }
		            \__tbl_set_td_some_headers:Vnn \l__tbl_column_int     { -1 } { columns }
		            \__tbl_set_td_some_headers:Vnn \l__tbl_column_neg_int {  1 } { columns }
	    	      }
    		  }
          }
      }
    \int_set:Nn \l__tbl_next_column_int { \l__tbl_column_int + 1 }
    \__tbl_get_struct_cell:VVN \l__tbl_row_int \l__tbl_next_column_int \l__tbl_cell_id_int
    \int_compare:nT { \l__tbl_cell_id_int < 0 }
      % We're in a multicolumn.  Also grab headers for cells to the right.
      {
        \int_incr:N \l__tbl_column_int
        \__tbl_set_td_headers: % recurse
        \int_decr:N \l__tbl_column_int
      }
  }

\cs_new:Npn \__tbl_set_td_some_headers:Vnn #1#2#3 % #1: start, #2: step, #3: rows|columns
  {
    \bool_set_false:N \l__tbl_found_header_bool
    % decr/incr a positively/negatively indexed cell.
    % If we find a positively/negatively indexed header cell,
    % record it and all subsequent header cells,
    % but stop when we find a non-header cell.
    % As a consequence, positively/negatively indexed headers can only be headers of cells that come after/before.
    \int_step_inline:nnnn { #1 } { #2 } { 0 }
      {
        \clist_if_in:cnTF { l__tbl_header_ #3 _clist } { ##1 }
          {
            \bool_set_true:N \l__tbl_found_header_bool
            \__tbl_get_struct_cell:VVnnN \l__tbl_row_int \l__tbl_column_int { #3 } { ##1 } \l__tbl_cell_id_int
            \int_set:Nn \l_tmpb_int { \int_abs:n { \l__tbl_cell_id_int } }
            \str_set:NV \l_tmpa_str \l_tmpb_int
            \str_set:Ne \l_tmpa_str { ( ID . \__tbl_zero_pad:N \l_tmpa_str ) }
            \clist_put_right:NV \l__tbl_headerattribute_clist \l_tmpa_str
          }
          { \bool_if:NT \l__tbl_found_header_bool { \prg_break: } }
      }
  }

\cs_new:Npn \__tbl_get_struct_cell:nnN #1#2#3 % #1: row, #2: column, #3: result
  % If we look for an index that is too large, we get 0.
  {
    \clist_set:Ne \l_tmpb_clist { \seq_item:Nn \g__tbl_struct_cells_seq { #1 } }
    \clist_if_exist:NTF \l_tmpb_clist
      {
        \int_set:Nn \l_tmpa_int { \clist_count:N \l_tmpb_clist }
        \int_compare:nNnTF { #2 } < { \l_tmpa_int+1 }
          {
            \int_set:Ne #3 { \clist_item:Nn \l_tmpb_clist { #2 } }
          }
          {
            \int_zero:N #3
          }
      }
      {
        \int_zero:N #3
      }
  }
\cs_generate_variant:Nn \__tbl_get_struct_cell:nnN { nVN, VnN, VVN }

\cs_new:Npn \__tbl_get_struct_cell:VVnnN #1#2#3#4#5
  % #1&2: starting row&column, #3: change rows|columns, #4: change to ..., #5: result
  {
    \str_if_eq:nnTF { #3 } { rows }
      {
        \__tbl_get_struct_cell:nVN {#4} #2 #5
      }
      {
        \__tbl_get_struct_cell:VnN #1 {#4} #5
      }
  }
